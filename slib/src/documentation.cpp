#include <iostream>
#include "documentation.h"
using namespace std;

const char *default_license_text(void) {
  return R"(
			  /*
			   * This file is part of the PROJECT_NAME
			   * (GITHUB_URL).
			   * Copyright (c) 2020 AUTOR.
			   *
			   * This program is free software: you can redistribute it and/or modify
			   * it under the terms of the GNU General Public License as published by
			   * the Free Software Foundation, version 3.
			   *
			   * This program is distributed in the hope that it will be useful, but
			   * WITHOUT ANY WARRANTY; without even the implied warranty of
			   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
			   * General Public License for more details.
			   *
			   * You should have received a copy of the GNU General Public License
			   * along with this program. If not, see <http://www.gnu.org/licenses/>.
			   */
			  )";
}

/**
 *
 */
void usage(void) {
  cout << R"(
usage: slib [--] filename.slib 
  --o   	overwrite files.
  --f   	format files with clang.
  --api 	produce client API interface.
  --lib 	produce shared library interface.
  --guid    produce GUID header.
  --uuidgen generate new GUID id using uuidgen. All GUIDs will be 
          regenerated. Therefore all files need regeneration.
  --doc     produce documentation file for the project generation.
  --stub    produce a stub demo program, client API and shared library.
  --ref     quick reference
  --help    documentation

Shared Library Interface Generator (slib)
by Anthony Matarazzo 
GNU General Public License as published by the Free Software Foundation, version 3
	  )" << endl;
}

/**
 *
 */
void quick_reference(void) {
  usage();
  cout << R"(
Quick Reference
===============

"//", "/*", "*/"
comment 

"@" 
documentation

"clang-format"
also: format,	fmt,	LLVM, Google, Chromium, Mozilla, WebKit
formatting statement

"shared-library-template filename.cpp filename.h;"
also: shared_library_template, shared library template, template, tlibrary, tlib
template input statement

"license filename.cpp filename.h;" also : lic
license include statement

"client-api filename.h;" also: client_api, client api, client, api
API output statement

"shared-library filename.cpp filename.h;" 
	also: shared_library, shared library, shared, library,	lib
library output statement

"namespace uxapi;" also: ns, nm
c++ namespace statement

"[00000000-0000-0000-0000-000000000000] class class_name_t;"
class definition statement

"[00000000-0000-0000-0000-000000000000] return_type member_function_name( parameter_types... );"
API definition statement

)" << endl;
  ;
}

void full_documentation(void) {

  quick_reference();

  cout << R"(
What slib does
============

slib is a command line source generation utility for shared library dynamic loading. It is used for c++ development. The program generates source code based upon settings within a .slib text files to provide the facility with minimial coding. The boiler plate code is generated by this program. It provides this facility using the standard library and its function object type. The class within the client API header file will link to the named library (.so or .dll) and resolve the symbols automatically. 

The source code generated can be included in projects to manage shared library and interface objects that are version oriented and associated by a GUID.

.slib file syntax
=================

.slib files are text files. The statements, definitions and settings are matched using case insensitivity. The statement word such as “shared-library-template” may appear in multiple forms. These forms provide user friendly syntax. For example, not using “-” between and placing spaces within the key phrase. There are also shortened versions and even mnemonic versions. These aid in shortening such a large asset, giving the designer the preference of style. See the documentation for each statement for details on their supported analogous key phrases.

Comments may be inside .slib files that document any aspect of. It is free form as all comments are. Comments may be single of multiple lines. The comment tags are the same as the c language.

Statements end with a semicolon. The system queues text lines until a “;” is met and then parses the statement. A statement can be separated on multiple lines and any portion can be indented.

Items may have documentation as well. Documentation lines appear above the statement and start with a ‘@’ character. There can be multiple ‘@’ characters for one statement. Each one is concatinated together. The ‘@’ is not included within the output. The documentation is inserted into the genersted .cpp, and .h files. This allows one to work more easily with the generated code base.

clang format is turned off for slib files since it is not source code. When working inside an IDE, you might edit one of these files (.slib). But clang-format does not format them well and causes disarray. Simply turn off formatting with “// clang-format off” near the top of the .slib file.

   
"//", "/*", "*/"
comment 

comment lines  -  not processed are start with “//”.  Comments cannot appear within statement lines. Commenting is provided to document the .slib process file. These items are ignored.  There are two types of comments that mimic the c syntax. These work very simularly.

"@" 
documentation

This is placed in the files generated for tracking and information. Large interfaces need this information. 

"clang-format"
formatting statement

The value is passed to the clang-format program in the "--style=" parameter. The value can be one of these: LLVM, Google, Chromium, Mozilla, WebKit.  	

Alternates: 
	format
	fmt
	LLVM
	Google
	Chromium
	Mozilla
	WebKit
  	
Note: LLVM, etc have to end in a semicolon. So in the file, place “LLVM;”.

"shared-library-template filename.cpp filename.h;"
template input statement

The statement names the files used to create the implementation. The files are boiler plate code used to manage the interface. There are two of them. A .cpp and a .h file. These template files are textual templates and have code in them dabbed with “marker tags” that are replaced by generated content specific to the desired interface. Using a template approach provides expansion capabilities. That is, other types of processes can be built into a template file other than the base ones provided and still used with this program. 
There are several analogous key phrases that can be used instead. All forms are listed below.

Alternatives:
shared_library_template
shared library template
template
tlibrary
tlib

"license filename.cpp filename.h;" 
license include statement

There are two files, a .cpp and a .h file. These files are included at the top of the generated code. Many source code releases require a licenses or a header at the top of source code files. If not included a default one is placed at the top naming the GNU free software license.

Alternatives:
	lic

"client-api filename.h;"
API output statement

The name of the API header file to generate as output. This file is included in the client API that will load the shared library. This statement names the output file specifically. When one is not given within the .slib file using this statement, the program will try to create an output file based upon the class name. Of course the class name is processed without the “_t” as a suffix and “.h” added to the end. The program will not overwrite a file if it exists already. It just exits. Files can be automatically overwritten by including “-–o” within the command line if desired. This is a protection that is enabled so as to not destroy source files.

Alternatives:
	client_api
	client api
	client
	api

"shared-library filename.cpp filename.h;"
library output statement

The names of the shared library linkage .cpp and header files. There are two string values. These are the files that the shared library includes within its compile base. The client and the shared library use these facilities to bind.

This statement names the output files specifically. When this is not given, the program will try to create an output file names based upon the class name. Of course the class name without the “_t” as suffix and “.h” as the output file name. As well an additional suffix is added to the class name: “_shared_library”. The program will not overwrite these files if one exists already. Exits. Files can be automatically overwritten by including “-–o” within the command line. This is a protection that is enabled to not destroy source files.

Alternatives:
	shared_library
	shared library
	shared
	library
	lib
	

"namespace uxapi;"
c++ namespace statement

The statement allows one to provide a namespace for the c++ class to extend. This namespace is the enclosing namespace for the header implementation for the client connection and the shared library implementation.  This allows one to use meaning domain words in multiple places and helps organize systems to integrate for source compile.

Alternatives:
	ns
	nm


"[00000000-0000-0000-0000-000000000000] class class_name_t;"
class definition statement

The statement allows for the major class name to be given for the client API class. This is the class that the program builds. The name is one that will be inherited or used as an object directly within the project. The class provides several automatic member functions that provide under the hood client and share library linkage. The class inherits from the base to enable loading shared libraries from the os layer.

The statement starts with a GUID block. It must be formatted precisely, without spaces, at the beginning, and between “[“ and “]”. The GUID is a standard format as generated by the “uuidgen” program on linux consisting of five segments. Each segment separated by a “-”. All characters are hexadecimal and can be upper or lower.

These can be automatically generated. See the command line options.

There is no alternative phrasing for this statement. The statement must appear precisely as shown above.

"[00000000-0000-0000-0000-000000000000] return_type member_function_name( parameter_types... );"
API definition statement

The API definition statements provides publishing and linkage of the named function. The function will exist within both modules with similar names. However the shared library will export these while the client program uses the linkage map to locate their pointer.

The linkage within the client API header is established as a std::function member variable while the shared library has the c exported interface. Parameters are given in the same syntax as it would be if described in a c function prototype. These are parsed and the information is used to link the c style functions to the standard library in generated source fashion. 

These parameters have to be comprised of base c types for the communication of parameters between the client and the shared library to be reliable. So using the standard library objects within this context is not recommended. This is primarily due to the fact that c++ compilers produce different run-time type name mangling, use multiple std template libraries during compilation. The use of GUID over comes the name mangling problem with 16 bytes. Raw data pointers are supported which is consistent with class and struct types. The standlard library types “double”, “float”, “int”, “short”, “char”, “unsigned char”, “char *”, “unsigned char *” and standard library types such as <cstdint> are of value.

There is no alternative phrasing for this statement. The statement must appear precisely as shown above.

)" << endl;
}
